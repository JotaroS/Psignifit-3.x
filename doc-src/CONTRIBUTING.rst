=============================
Contributing to psignifit 3.0
=============================

psignifit 3.0 is free software. You are free to modify the software under the terms of the license
that is distributed with psignifit 3.0. We welcome developers that want to contribute to psignifit 3.0.

Naming Convention
-----------------

The psignifit 3.x code base is logically split into several components:

:psi++:
    The C++ *engine* of psignifit.
:psipy:
    Python interface to ``psi++`` written using the ``Python-C API``.
:pypsignifit:
    High level Python interface, including visualisation methods.
:swignifit:
    Python interface to ``psi++`` autogenerated using the ``swig`` tool.
:rpsignift:
    R interface to ``psi++``.

We refer to previous versions of psignifit (2.5.6 and before) as
**psignifit-classic**.

Git-Repository
--------------

We use `git <http://git-scm.com/>`_ for version control, development snapshots of psignifit can be obtained like this::

    git clone git://psignifit.git.sourceforge.net/gitroot/psignifit/psignifit 

Layout
......

Every developer has his/her own branch, and we use the master branch to do
integration. Hence we have the following layout in the sourceforge repository:

:master:
    the integration branch
:ingo/master:
    Ingo's main branch
:val/master:
    Valentin's main branch

Commits
.......

To make it easier to keep track of the development of psignifit, we use the following marks for commits:

* [NF]    new feature
* [BF]    bug fix
* [RF]    refactoring
* [FO]    code formatting (adding spaces etc.)
* [UT]    unit tests
* [DOC]   documentation

We may additionally use the following marks to identify what parts of the code
base we worked on:

* C++
* swig
* py
* R


Extending
---------

In principle every part of the library can be replaced. This is generally done by deriving from the fundamental base classes.
An exception is adding a new sigmoid:

Adding a new sigmoid
....................

Adding a new sigmoid requires two steps:

1. Write a new class that inherits from PsiSigmoid
2. If you want your new sigmoid to work with mwCore objects, you have to add a label for that, too.
    The mwCore class scales the second parameter such that w can be directly interpreted as the
    width of the region in which the sigmoid still rises significantly. What to "rise significantly"
    means is parameterized by the parameter alpha of the mwCore. The default alpha==0.1 indicates
    that w is the width of the range over which the sigmoid rises from 0.1 to 0.9. Thus, the scaling
    of the second parameter obviously depends on the sigmoid.
    The constructor for the mwCore class looks roughly like this::

        mwCore::mwCore ( int sigmoid, double al )
                : sigmtype(sigmoid), alpha(al), zshift(0) {
            switch (sigmoid) {
            case 1:
                ...
                break;
            /////////////// here ////////////////
            default:
                throw NotImplementedError();
            }
        }

    At the position marked by::

        /////////////// here ////////////////

    in the above code example, you should add a new case that defines all the scaling parameters
    depending on your sigmoid. zalpha scales w to the correct range, zshift is an additional
    shift to ensure the the sigmoid has an output value of 0.5 at an input value of 0.
