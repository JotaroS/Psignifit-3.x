=============================
Contributing to psignifit 3.0
=============================

psignifit 3.0 is free software. You are free to modify the software under the terms of the license
that is distributed with psignifit 3.0. We welcome developers that want to contribute to psignifit 3.0.

Naming Convention
-----------------

The psignifit 3.x code base is logically split into several components:

:psi++:
    The C++ *engine* of psignifit.
:psipy:
    Python interface to ``psi++`` written using the ``Python-C API``.
:pypsignifit:
    High level Python interface, including visualisation methods.
:swignifit:
    Python interface to ``psi++`` autogenerated using the ``swig`` tool.
:rpsignift:
    R interface to ``psi++``.

We refer to previous versions of psignifit (2.5.6 and before) as
**psignifit-classic**.

Note that we are slowly deprecating ``psipy`` in favour of ``swignifit``.

Build System
------------

We use a combination of `distutils <http://docs.python.org/library/distutils.html>`_ and `make <http://www.gnu.org/software/make/>`_
to build the software.

There are two ``Makefiles``:

:Makefile:
    main makefile
:src/Makefile:
    psi++ makefile

Note that main makefile contains targets to invoke the ``psi++`` makefile. The
main targets are ``build``, ``install``, ``clean`` and ``test``. The main
targets will invoke separate targets to build the individual components of the
software. If during development you wish to build components separately, have a
look at the main makefile, it should contain everything you need.

There are several ``setup.py`` files, which we use to compile the ``psi++`` and
the python interfaces:

:setup_basic.py:
        contains definitions
:setup_psipy.py:
        will compile/install ``psipy`` only
:setup_swignifit.py:
        will compile/install ``swignifit`` only
:setup.py:
        will compile ``psipy`` and ``swignifit``

When asked to install, the setup scripts will also install ``pypsignifit``.


Git-Repository
--------------

We use `git <http://git-scm.com/>`_ for version control, development snapshots of psignifit can be obtained like this::

    git clone git://psignifit.git.sourceforge.net/gitroot/psignifit/psignifit 

Layout
......

Every developer has his/her own branch, and we use the master branch to do
integration. Hence we have the following layout in the sourceforge repository:

:master:
    the integration branch
:ingo/master:
    Ingo's main branch
:val/master:
    Valentin's main branch

Commits
.......

To make it easier to keep track of the development of psignifit, we use the following marks for commits:

* [NF]    new feature
* [BF]    bug fix
* [RF]    refactoring
* [FO]    code formatting (adding spaces etc.)
* [UT]    unit tests
* [DOC]   documentation

We may additionally use the following marks to identify what parts of the code
base we worked on:

* C++
* swig
* py
* R
* build

Merging
.......

For easy tracking of what changes were absorbed during merge, we advice to
enable merge summary within git:

    git-config merge.summary true

Development Snapshots
.....................

Development snapshots are made on a regular basis. They consist of the following steps

* create a tarball. The tarball should be named as
  ``psignifit3.0_beta_DD-MM-YYYY.tar.gz``
* create a tag in the git repository. The tag for a snapshot should be
  ``snap-YYYY-MM-DD``
* upload the tarball to sourceforge (into a new folder!)
* push tags

Tags
....

Tags should mark critical points in the development history in the following way:

* ``snap-YYYY-MM-DD`` marks the release of a development snapshot
* ``doc-YYYY-MM-DD`` marks a modification of the documentation that has been uploaded to sourceforge.

Extending
---------

Coding Style
............

We try to adhere to the:
`Numpy Docstring Conventions <http://projects.scipy.org/numpy/wiki/CodingStyleGuidelines#docstring-standard>`_
as far as possible.


Adding a new sigmoid
....................

In principle every part of the library can be replaced. This is generally done by deriving from the fundamental base classes.
An exception is adding a new sigmoid:

Adding a new sigmoid requires two steps:

1. Write a new class that inherits from PsiSigmoid
2. If you want your new sigmoid to work with mwCore objects, you have to add a label for that, too.
    The mwCore class scales the second parameter such that w can be directly interpreted as the
    width of the region in which the sigmoid still rises significantly. What to "rise significantly"
    means is parameterized by the parameter alpha of the mwCore. The default alpha==0.1 indicates
    that w is the width of the range over which the sigmoid rises from 0.1 to 0.9. Thus, the scaling
    of the second parameter obviously depends on the sigmoid.
    The constructor for the mwCore class looks roughly like this::

        mwCore::mwCore ( int sigmoid, double al )
                : sigmtype(sigmoid), alpha(al), zshift(0) {
            switch (sigmoid) {
            case 1:
                ...
                break;
            /////////////// here ////////////////
            default:
                throw NotImplementedError();
            }
        }

    At the position marked by::

        /////////////// here ////////////////

    in the above code example, you should add a new case that defines all the scaling parameters
    depending on your sigmoid. zalpha scales w to the correct range, zshift is an additional
    shift to ensure the the sigmoid has an output value of 0.5 at an input value of 0.

Adding a new source file
........................

When adding a new C++ source or header file you will have to:

* add the file to the git repository
* add the filename to the Makefile
* add the filename to the python setup file
